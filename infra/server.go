package infra

import (
	"context"
	"net/http"
	"regexp"
	"strings"
	"time"

	"git.countmax.ru/countmax/layoutconfig.api/domain"
	"git.countmax.ru/countmax/layoutconfig.api/internal/connmanager"
	"git.countmax.ru/countmax/layoutconfig.api/internal/permission"
	"git.countmax.ru/countmax/layoutconfig.api/internal/permission/cache"
	"git.countmax.ru/countmax/layoutconfig.api/internal/permission/cache/mem"
	"git.countmax.ru/countmax/layoutconfig.api/repos"
	"git.countmax.ru/countmax/pkg/logging"

	// nolint:gosec
	_ "net/http/pprof" // for remote profiling

	_ "git.countmax.ru/countmax/layoutconfig.api/docs" // docs is generated by Swag CLI, you have to import it.

	"github.com/gorilla/websocket"
	consulapi "github.com/hashicorp/consul/api"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/spf13/viper"
	echoSwagger "github.com/swaggo/echo-swagger"
	"go.uber.org/zap"
)

const (
	requestIDName                     = "request_id"
	periodHealthCheck   time.Duration = 30 * time.Second
	apiVersion          string        = "v2"
	listIDRegExpression string        = `(?m)^[0-9]{1,}(,[0-9]*)*$`
)

type Server struct {
	ctx       context.Context
	log       *zap.SugaredLogger
	consul    *consulapi.Agent
	mux       *echo.Echo
	metricmux *echo.Echo
	version   string
	githash   string
	build     string
	scope     string
	upgrader  *websocket.Upgrader
	config    *viper.Viper
	mService  *prometheus.GaugeVec
	mWS       *prometheus.GaugeVec
	mAPI      *prometheus.HistogramVec
	chCancel  <-chan struct{}
	fnCancel  context.CancelFunc
	repoM     *connmanager.Manager
	dmRepo    domain.IScreenRepo
	evRepo    domain.IEventRepo
	listReg   *regexp.Regexp
	extsvs    []connmanager.ExtServiceInterface
	perm      *permission.Manager
}

// NewServer builder main document server
func NewServer(ctx context.Context, version, build, githash string) *Server {
	newctx, cancel := context.WithCancel(ctx)
	upgrader := &websocket.Upgrader{
		CheckOrigin: func(r *http.Request) bool {
			return true
		},
		ReadBufferSize:  1024,
		WriteBufferSize: 1024,
	}
	s := &Server{
		ctx:      newctx,
		version:  version,
		githash:  githash,
		build:    build,
		upgrader: upgrader,
		mService: common,
		mWS:      api_websocket_connections,
		mAPI:     httpDuration,
		chCancel: ctx.Done(),
		fnCancel: cancel,
		listReg:  regexp.MustCompile(listIDRegExpression),
		extsvs:   make([]connmanager.ExtServiceInterface, 0, 2),
	}
	// fill config
	s.setConfig()
	s.setLogger(version, build, githash)
	ctxwithlog := logging.WithLogger(newctx, s.log)
	// fill token
	s.registerRepos(ctxwithlog)

	// start healthChecker
	go s.healthChecker(periodHealthCheck, s.chCancel)

	return s
}

// Run is running Server
func (s *Server) Run() {
	s.registerRoutes()
	// s.mux.HTTPErrorHandler = s.customHTTPErrorHandler
	hostportMain := s.config.GetString("httpd.main.host_port")
	s.log.Infof("http server starting main api on the [%s]", hostportMain)
	go func() {
		if err := s.mux.Start(hostportMain); err != http.ErrServerClosed {
			s.log.Fatalf("http server error: %v", err)
		}
	}()
	// metrics
	hostportMetrics := s.config.GetString("httpd.service.host_port")
	s.log.Infof("http server starting service api on the [%s]", hostportMetrics)
	go func() {
		if err := s.metricmux.Start(hostportMetrics); err != http.ErrServerClosed {
			s.log.Fatalf("http server error: %v", err)
		}
	}()
	s.consulRegister()
}

// Stop is stopping Server
func (s *Server) Stop() {
	s.log.Infof("got signal to stopping server")
	stopDuration := 5 * time.Second
	ctx, cancel := context.WithTimeout(context.Background(), stopDuration)
	defer cancel()
	defer s.consulDeRegister()
	s.fnCancel()
	go func(ctx context.Context) {
		if err := s.mux.Shutdown(ctx); err != nil {
			s.log.Fatal(err)
		}
	}(ctx)
	if err := s.metricmux.Shutdown(ctx); err != nil {
		s.log.Fatal(err)
	}
}

func (s *Server) registerRoutes() {
	// service metrics
	me := echo.New()
	me.HidePort = true
	me.HideBanner = true // hide banner ECHO
	me.Use(middleware.Recover())
	me.GET("/metrics", echo.WrapHandler(promhttp.Handler()))
	me.GET("/health", s.apiHealthCheck)
	// pprof
	dbg := me.Group("/debug")
	dbg.GET("/pprof/*", echo.WrapHandler(http.DefaultServeMux))
	s.metricmux = me

	// main api
	e := echo.New()
	e.HidePort = true
	e.HideBanner = true // hide banner ECHO
	e.Use(middleware.Recover())
	e.Use(middleware.RequestID())
	e.Use(s.customHTTPLogger)
	raworigins := s.config.GetString("httpd.allow_origins")
	e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		AllowOrigins: strings.Split(raworigins, ","),
		// AllowHeaders: []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept},
	}))
	// swagger on main
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	// common
	v2 := e.Group("/" + apiVersion)
	v2.Use(middleware.GzipWithConfig(middleware.GzipConfig{
		Level: 5,
	}))
	v2.GET("/layouts", s.apiLayouts)
	v2.GET("/layouts/:layout_id", s.apiLayoutByID, s.middlewareCheckLayout)
	v2.GET("/layouts/behaviors", s.apiBehaviors)
	v2.GET("/layouts/:layout_id/behaviors", s.apiBehaviorByLayoutID, s.middlewareCheckLayout)
	v2.PUT("/layouts/:layout_id/behaviors", s.apiBehaviorUpd, s.middlewareCheckLayout)

	v2.GET("/devices/:device_id/info", s.apiDeviceInfo)
	v2.GET("/devices/info", s.apiNewDeviceInfo)
	v2.GET("/version", s.apiVersion)
	v2.GET("/entities", s.apiEntities, s.middlewareCheckLayout)

	// data
	v2.GET("/data/inside", s.apiZoneDataInside)
	v2.GET("/data/inside/days", s.apiZoneDataInsideDay)
	v2.GET("/data/inside/days/range", s.apiZoneDataInsideRange)
	//
	// screenshots
	v2.GET("/screenshots", s.apiGetScreenshots, s.middlewareCheckLayout)
	v2.PUT("/screenshots", s.apiUpdScreenshotsStatus, s.middlewareCheckLayout)
	v2.GET("/screenshots/attime", s.apiGetScreenshotsAtTime, s.middlewareCheckLayout)
	//
	// data queue
	// data queue evaluation
	dataq := v2.Group("/data/queue")
	dataq.GET("/evaluations", s.apiZoneDataEvaluation, s.middlewareCheckLayout)
	dataq.GET("/recommendations", s.apiChainRecommendationsQueue)
	// data queue length
	qlength := dataq.Group("/length")
	qlength.GET("/stores", s.apiChainStoresDataQueue)
	qlength.GET("/stores/live", s.apiChainStoresDataQueueNow)
	qlength.GET("/zones", s.apiChainZonesDataQueue)
	qlength.GET("/zones/live", s.apiChainZonesDataQueueNow)
	// data attendance
	attend := v2.Group("/data/attendance")
	attend.GET("/stores", s.apiChainStoresDataAttendance)
	attend.GET("/stores/zones", s.apiChainZonesDataAttendance)
	attend.GET("/stores/entrances", s.apiChainEntrancesDataAttendance)
	attend.GET("/malls/zones", s.apiMallZonesDataAttendance)
	attend.GET("/malls/entrances", s.apiMallEntrancesDataAttendance)
	attend.GET("/malls/renters", s.apiRenterDataAttendance)

	// malls
	malls := v2.Group("/malls")
	malls.GET("", s.apiMalls, s.middlewareCheckLayout)
	malls.GET("/:layout_id", s.apiMallByID, s.middlewareCheckLayout)
	// zones
	malls.GET("/zones", s.apiMallZones)
	malls.GET("/zones/:zone_id", s.apiMallZoneByID)
	// renters
	malls.GET("/renters", s.apiRenters)
	malls.GET("/renters/:renter_id", s.apiRenterByID)
	// entrances
	malls.GET("/entrances", s.apiMallEntrances)
	malls.GET("/entrances/:entrance_id", s.apiMallEntranceByID)
	// devices
	malls.GET("/devices", s.apiMallDevices)
	malls.GET("/devices/:device_id", s.apiMallDeviceByID)

	// chains
	chains := v2.Group("/chains")
	chains.GET("", s.apiChains)
	chains.GET("/:layout_id", s.apiChainByID, s.middlewareCheckLayout)
	chains.POST("", s.apiCreateChain, s.middlewareCheckLayout)
	chains.DELETE("/:layout_id", s.apiDeleteChain, s.middlewareCheckLayout)
	chains.PUT("", s.apiUpdChain, s.middlewareCheckLayout)
	// stores
	chains.GET("/stores", s.apiChainStores)
	chains.GET("/stores/:store_id", s.apiChainStoreByID, s.middlewareCheckStore)
	chains.POST("/stores", s.apiCreateChainStore, s.middlewareCheckLayout)
	chains.DELETE("/stores/:store_id", s.apiDeleteChainStore, s.middlewareCheckLayout)
	chains.PUT("/stores", s.apiUpdChainStore, s.middlewareCheckLayout)
	// entrances
	chains.GET("/entrances", s.apiChainEntrances)
	chains.GET("/entrances/:entrance_id", s.apiChainEntranceByID, s.middlewareCheckEnter)
	chains.POST("/entrances", s.apiCreateChainEntrance, s.middlewareCheckLayout)
	chains.DELETE("/entrances/:entrance_id", s.apiDeleteChainEntrance, s.middlewareCheckLayout)
	chains.PUT("/entrances", s.apiUpdChainEntrance, s.middlewareCheckLayout)
	chains.POST("/entrances/bindto/zone", s.apiCreateChainBindEntranceZone, s.middlewareCheckLayout)
	chains.PUT("/entrances/bindto/zone", s.apiUpdChainBindEntranceZone, s.middlewareCheckLayout)
	chains.DELETE("/entrances/bindto/zone", s.apiDeleteChainBindEntranceZone, s.middlewareCheckLayout)
	chains.POST("/entrances/bindto/store", s.apiCreateChainBindEntranceStore, s.middlewareCheckLayout)
	chains.PUT("/entrances/bindto/store", s.apiUpdChainBindEntranceStore, s.middlewareCheckLayout)
	chains.DELETE("/entrances/bindto/store", s.apiDeleteChainBindEntranceStore, s.middlewareCheckLayout)
	// events
	chains.GET("/events", s.apiChainEvents)
	chains.GET("/events/ws", s.serveChainEventsWS)
	chains.GET("/events/wss", s.serveChainEventsWS)
	// zones
	chains.GET("/zones", s.apiChainZones)
	chains.POST("/zones", s.apiCreateChainZone, s.middlewareCheckLayout)
	chains.GET("/zones/:zone_id", s.apiChainZoneByID)
	chains.DELETE("/zones/:zone_id", s.apiDeleteChainZone, s.middlewareCheckLayout)
	chains.PUT("/zones", s.apiUpdChainZone, s.middlewareCheckLayout)
	// zones states
	chains.GET("/zones/states", s.apiChainZonesStates, s.middlewareCheckLayout)
	chains.GET("/zones/states/last", s.apiChainZonesLastStates, s.middlewareCheckLayout)
	chains.GET("/zones/states/attime", s.apiChainZoneStateAtTime, s.middlewareCheckLayout)
	// devices
	chains.GET("/devices", s.apiChainDevices)
	chains.POST("/devices", s.apiCreateChainDevice, s.middlewareCheckLayout)
	chains.GET("/devices/:device_id", s.apiChainDeviceByID)
	chains.DELETE("/devices/:device_id", s.apiDeleteChainDevice, s.middlewareCheckLayout)
	chains.PUT("/devices", s.apiUpdChainDevice, s.middlewareCheckLayout)
	// device/tracks
	chains.GET("/devices/tracks", s.apiChainDeviceTracks)
	chains.GET("/devices/tracks/attime", s.apiChainDeviceTracksAt)
	// sensors
	chains.GET("/sensors", s.apiChainSensors, s.middlewareCheckLayout)
	chains.GET("/sensors/:sensor_id", s.apiChainSensorByID, s.middlewareCheckLayout)
	chains.POST("/sensors", s.apiCreateChainSensor, s.middlewareCheckLayout)
	chains.DELETE("/sensors/:sensor_id", s.apiDeleteChainSensor, s.middlewareCheckLayout)
	chains.PUT("/sensors", s.apiUpdChainSensor, s.middlewareCheckLayout)
	chains.POST("/sensors/bindto/entrance", s.apiCreateBindChainSensorEntrance, s.middlewareCheckLayout)
	chains.PUT("/sensors/bindto/entrance", s.apiUpdBindChainSensorEntrance, s.middlewareCheckLayout)
	chains.POST("/sensors/bindto/zone", s.apiCreateChainBindSensorZone, s.middlewareCheckLayout)
	chains.GET("/sensors/bindto/zone", s.apiGetChainBindSensorZone, s.middlewareCheckLayout)
	chains.PUT("/sensors/bindto/zone", s.apiUpdBindChainSensorZone, s.middlewareCheckLayout)
	chains.DELETE("/sensors/bindto/entrance", s.apiDeleteChainBindSensorEntrance, s.middlewareCheckLayout)
	chains.DELETE("/sensors/bindto/zone", s.apiDeleteChainBindSensorZone, s.middlewareCheckLayout)

	// references
	ref := v2.Group("/references")
	ref.GET("", s.apiReferences)
	ref.GET("/categories", s.apiRefCategories)
	ref.GET("/prices", s.apiRefPriceSegments)
	ref.GET("/kindzone", s.apiRefKindZones)
	ref.GET("/kindenter", s.apiRefKindEnters)

	// reports
	rep := v2.Group("/reports", s.middlewareCheckLayout)
	rep.GET("", s.apiReports)
	rep.GET("/:report_id/files", s.apiReportFiles)
	rep.GET("/:report_id/files/:file_id", s.apiReportFileContent)

	e.Static("/", "asset")

	s.mux = e
}

func (s *Server) registerRepos(ctx context.Context) {
	s.log.Debug("start registerRepos")
	defer s.log.Debug("finish registerRepos")

	m, err := connmanager.New(ctx, s.config)
	if err != nil {
		s.log.Fatalf("connmanager.New failed: %s", err)
	}
	s.repoM = m
	// device.manager init
	dmIsUse := s.config.GetBool("devicemanager.isuse")
	if dmIsUse {
		// aliases := make(map[string][]string)
		aliasesSRC := s.config.GetStringMapStringSlice("devicemanager.aliases")
		aliases := make(map[string][]string)
		aliases[aliasesSRC["src"][0]] = aliasesSRC["dest"]
		// fmt.Printf("aliases: %+v\n", aliases)
		timeoutDM := s.config.GetDuration("devicemanager.timeout")
		dsnDM := s.config.GetString("devicemanager.url")
		dmRepo, err := repos.NewDMDB(aliases, dsnDM, timeoutDM, s.log)
		if err != nil {
			s.log.Fatalf("device.manager connect to DB failed, %v", err)
		}
		s.dmRepo = dmRepo
		s.extsvs = append(s.extsvs, dmRepo)
	}

	// event init
	evIsUse := s.config.GetBool("events.isuse")
	if evIsUse {
		timeoutEV := s.config.GetDuration("events.timeout")
		dsnEV := s.config.GetString("events.url")
		evRepo, err := repos.NewEvRepo(dsnEV, timeoutEV, s.log)
		if err != nil {
			s.log.Fatalf("events connect to DB failed, %v", err)
		}
		s.evRepo = evRepo
		s.extsvs = append(s.extsvs, evRepo)
	}
	permissionPolicy := permission.DefaultAllow
	if s.config.GetString("permissions.policy") != "allow" {
		permissionPolicy = permission.DefaultDeny
		s.log.Warn("set default deny policy")
	}

	// perm manager
	var c cache.RepoInterface
	expire := s.config.GetDuration("permissions.cache.expire")
	if s.config.GetString("permissions.cache.url") == "memory" {
		c = mem.New(expire)
		pm := permission.NewManager(c, s.repoM, permissionPolicy, expire)
		s.perm = pm
		return
	}
	s.log.Fatalf("unsupported cache url %s, allowed only memory", s.config.GetString("permissions.cache.url"))
}

func (s *Server) healthChecker(period time.Duration, cancel <-chan struct{}) {
	s.log.Debugf("starting healthChecker")
	defer s.log.Debugf("stopped healthChecker")
	tick := time.NewTicker(period)
	defer tick.Stop()
	for {
		select {
		case <-cancel:
			return
		case <-tick.C:
			s.log.Debug("time to healthCheck")
			ctx, cancel := context.WithTimeout(context.Background(), period)
			err := s.healthCheck(ctx)
			if err != nil {
				s.log.Errorf("healthCheck error, %s", err)
			}
			cancel()
		}
	}
}

func (s *Server) healthCheck(ctx context.Context) error {
	// check countmax
	generalHealth := true
	var generalErr error
	for _, svc := range s.extsvs {
		scope := svc.Scope()
		dest := svc.Dest()
		if err := svc.Health(ctx); err != nil {
			generalHealth = false
			s.mService.WithLabelValues(scope, dest, s.version, s.githash, s.build).Set(0)
			generalErr = err
		} else {
			s.mService.WithLabelValues(scope, dest, s.version, s.githash, s.build).Set(1)
		}
	}
	// countmax repos [+commonapi]
	for _, svc := range s.repoM.GetExtServices() {
		scope := svc.Scope()
		dest := svc.Dest()
		if err := svc.Health(ctx); err != nil {
			generalHealth = false
			s.mService.WithLabelValues(scope, dest, s.version, s.githash, s.build).Set(0)
			generalErr = err
		} else {
			s.mService.WithLabelValues(scope, dest, s.version, s.githash, s.build).Set(1)
		}
	}
	// general
	if !generalHealth {
		s.mService.WithLabelValues("general", "localhost", s.version, s.githash, s.build).Set(0)
		return generalErr
	}
	s.mService.WithLabelValues("general", "localhost", s.version, s.githash, s.build).Set(1)
	return generalErr
}

// [ macroses ]
